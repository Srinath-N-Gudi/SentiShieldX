# APP/run.py


import os
import io
import sys
import secrets
import logging

from flask_login import login_user, logout_user, current_user, login_required
from flask import render_template, request, redirect, url_for, jsonify, flash

from Database.telegram_database import TelegramDatabase, TDB_KEYS
from Database.db import db, User

from init import app

from features.bots.telegram import TelegramBot
from features.ytca import CommentAnalyzer
from features.Cyber import Cyber
from features.bots import bot_resp

from telegram.helpers import escape_markdown

from dotenv import load_dotenv

LOGGING_ENABLED = True



sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')
  
logging.basicConfig(
    level=logging.ERROR,
    format='[%(asctime)s - %(levelname)s] - %(message)s',
    handlers=[
        logging.FileHandler('LOG.log'),
        logging.StreamHandler()
    ],
    encoding='utf-8'
)
logging.disable = not LOGGING_ENABLED


logging.info("Loading Environment Variables")
load_dotenv()
logging.info("Loading Complete")

# Initialize AI models
logging.info("Setting up AI Models")
cyber = Cyber('multilingual', device='cpu')
logging.info("Setup Complete")

logging.info("Setting Up Analyzers")
youtube_comment_analyzer = CommentAnalyzer(cyber)
logging.info('Setup Complete')

TELEGRAM_BOT_TOKEN = os.getenv('TELEGRAM-BOT-TOKEN')

# Initialize Telegram Bot

telegramDataBase = TelegramDatabase()
bot = TelegramBot(token=TELEGRAM_BOT_TOKEN,
                  database= telegramDataBase,
                  cyber = cyber,
                  message_handler=bot_resp.handle_message)
bot.start()


# 2. Add commands via decorators
@bot.command('start')
async def start(update, context):
    """ Start Handler for the Bot """
    await update.message.reply_text("üöÄ Bot started! Use /register <uuid> to register")

@bot.command('register')
async def register(update, context):
    """ Registers the bot, links the teleggram_id of the client to the uuid for later use case
    
        NOTE: Works only in private chats

     """

    if update.message.chat.type != "private":
        await update.message.reply_text(f"‚ùå Please message [me]({escape_markdown('https://t.me/SentiShield_Bot', version=2)}) directly in private chat for registration !", parse_mode="MarkdownV2")
        return

    content = (update.message.text)[9:].strip()

    with app.app_context():
        
        if User.query.filter_by(uuid=content).first():
            telegramDataBase.register_uuid(str(update.effective_user.id), content)
            await update.message.reply_text(f"Registration Sucessfull, Please verify the bot with /verify <varification_code>")
        else:
            await update.message.reply_text(f"Registration Failed. No Such registerd user exists")

@bot.command('verify')
async def verify(update, context):

    """Final Authentication of the bot by checking uuid, telegram_id and verification code ( Which was generated by linking uuid and telegram_id )
        NOTE: Works only in private chats
    """

    if update.message.chat.type != "private":
        await update.message.reply_text(f"‚ùå Please message [me]({escape_markdown('https://t.me/SentiShield_Bot', version=2)}) directly in private chat for verification !", parse_mode="MarkdownV2")
        return
    
    #Step 2: Verify using code from web
    if telegramDataBase.is_verified(update.effective_user.id):
        await update.message.reply_text("‚úÖ Already verified!")
        return

    code = context.args[0] if context.args else None

    if not code:
        await update.message.reply_text("‚ùå Usage: /verify <code>")
        return

    if telegramDataBase.verify_code(update.effective_user.id, code):
        await update.message.reply_text(
            "üéâ Verification successful!\n"
            "You can now use all bot features"
        )
    else:
        await update.message.reply_text(
            "‚ùå Verification failed\n"
            "Possible reasons:\n"
            "- Wrong code\n"
            "- Code expired\n"
            "- No active registration\n"
            "Try /register again if needed"
        )



# Routes
#### Signup, Login and Logout system #######

@app.route('/signup', methods=['GET', 'POST'])
def signup():
    if request.method == 'POST':
        try:
            username = request.form['username'].strip()
            email = request.form['email'].strip()
            password = request.form['password'].strip()

            if not username or not email or not password:
                flash('All fields are required', 'error')
                return redirect(url_for('signup'))

            if User.query.filter_by(email=email).first():
                flash('Email already registered', 'error')
                return redirect(url_for('signup'))
                
            if User.query.filter_by(username=username).first():
                flash('Username already taken', 'error')
                return redirect(url_for('signup'))

            new_user = User(username=username, email=email)
            new_user.set_password(password)
            
            db.session.add(new_user)
            db.session.commit()
            
            login_user(new_user)
            return redirect(url_for('dashboard'))

        except Exception as e:
            db.session.rollback()
            flash('Registration failed. Please try again.', 'error')
            return redirect(url_for('signup'))
    
    return render_template('signup.html')

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        email = request.form['email']
        password = request.form['password']        
        user = User.query.filter_by(email=email).first()
        
        if user and user.check_password(password):
            login_user(user)
            return redirect(url_for('dashboard'))
        else:
            flash('Invalid email or password', 'error')
    
    return render_template('login.html')

@app.route('/logout')
@login_required
def logout():
    logout_user()
    return redirect(url_for('index'))

##############################################################################
######################## Home Page ###########################################

@app.route('/')
def index():
    if current_user.is_authenticated:
        return redirect(url_for('dashboard'))
    return render_template('index.html')

@app.route('/dashboard')
@login_required
def dashboard():
    """
    Logged in version of index.html
    """
    return render_template('dashboard.html', user=current_user)

##############################################################################

################## Features Section ##########################################
# Features
@app.route('/ytca')
def ytca():
    """
    ytca: Youtube Comment Analyzer
    """
    return render_template('ytca.html')

@app.route('/analyze', methods=['POST'])
def analyze():
    """
    Youtube comments are analyzed with `analyze_comment(video_url, num_counts)`
    video_url : url of the youtube video
    num_counts: No of comments to analyze ( Default set to 150 )
    
    Returns:
        JSON of {hate, positive, neutral percentages }
    
    """
    
    
    video_url = request.form.get('url')
    results = youtube_comment_analyzer.analyse_comment(video_url, num_comments=150) 
    
    return jsonify({
        'hate'    : round(results['hate_comments']     / results['total_comments'] * 100, 2),
        'positive': round(results['positive_comments'] / results['total_comments'] * 100, 2),
        'neutral' : round(results['neutral_comments']  / results['total_comments'] * 100, 2)
    })

# Bots 
@app.route('/bots')
@login_required
def bots():
    """
    Showing available bots 
    In this case: Telegram, Discord
    
    """
    return render_template('bots.html')

@app.route('/tbs')
@login_required
def tbs():  ## tbs : Telegram Bot Setup
    """Generate and display verification code"""
    if telegramDataBase.is_verified(telegramDataBase.get_telegram_id(current_user.uuid)):
        return redirect(url_for('telegram_groups'))
    else: 
        verification_code = telegramDataBase.generate_verification_code(current_user.uuid)
        return render_template(
            'telegram_bot_setup.html',
            user_uuid = current_user.uuid,
            verification_code=verification_code,
        )

@app.route('/save_hate_speech_settings/<string:group_id>', methods=['POST'])
@login_required
def save_hate_speech_settings(group_id):

    """
    Saving the gropu settings of `telegram_bot`
    """
    try:
        data = request.get_json()
        settings = {
            TDB_KEYS.PROTECTION_ENABLED:    data.get(TDB_KEYS.PROTECTION_ENABLED, True),
            TDB_KEYS.MUTE_DURATION :        data.get(TDB_KEYS.MUTE_DURATION,      1),
            TDB_KEYS.WARNING_MESSAGE:       data.get(TDB_KEYS.WARNING_MESSAGE,    ''),
            TDB_KEYS.MUTE_COUNT:            data.get(TDB_KEYS.MUTE_COUNT,         3),
            TDB_KEYS.REPEAT_ACTION:         data.get(TDB_KEYS.REPEAT_ACTION,      'kick'),
            TDB_KEYS.ALLOW_BANNING:         data.get(TDB_KEYS.ALLOW_BANNING,      True),
            TDB_KEYS.ADMIN_MESSAGE:         data.get(TDB_KEYS.ADMIN_MESSAGE,       '')
        }

        if not telegramDataBase.save_hate_speech_settings(group_id, current_user.uuid, settings):
            return jsonify({'success': False, 'message': 'Failed to save settings'}), 500

        return jsonify({'success': True, 'message': 'Settings saved'})
        
    except Exception as e:
        logging.error(f"Error saving settings: {str(e)}")
        return jsonify({'success': False, 'message': 'Server error'}), 500
        
####### Telegram Group System

@app.route('/telegram_groups')
@login_required
def telegram_groups():
    """
    Displaying all groups user has put our `telegram bot` in
    """
    try:
        if not telegramDataBase.is_verified(telegramDataBase.get_telegram_id(current_user.uuid)):
            return redirect(url_for('tbs'))
        groups = telegramDataBase.get_user_groups(current_user.uuid)
        
        # Convert SQLite timestamp to readable format
        for group in groups:
            try:
                group['added'] = datetime.strptime( group['added'],
                                                    '%Y-%m-%d %H:%M:%S').strftime('%b %d, %Y %H:%M')
            except:
                group['added'] = "Recently"
                
        return render_template('telegram_groups.html', groups=groups)
        
    except Exception as e:
        logging.error(f"Error loading groups: {str(e)}")
        flash("Failed to load groups. Please try refreshing.", "error")
        return render_template('telegram_groups.html', groups=[])


@app.route('/refresh_groups', methods=['POST'])
@login_required
def refresh_groups():
    try:
        telegram_id = telegramDataBase.get_telegram_id(current_user.uuid)
        if not telegram_id:
            return jsonify({"error": "Telegram account not linked"}), 400

        current_groups = telegramDataBase.get_user_groups(current_user.uuid)
        removed_count = 0

        # Create a new event loop
        import asyncio
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)

        async def check_groups():
            tasks = []
            for group in current_groups:
                task = asyncio.create_task(
                    process_group(group)
                )
                tasks.append(task)
            return await asyncio.gather(*tasks)

        async def process_group(group):
            nonlocal removed_count
            try:
                is_member = await bot.check_membership_safe(group['id'])
                if not is_member:
                    try:
                        await bot.app.bot.get_chat(group['id'])
                        return 
                    except Exception:
                        telegramDataBase.remove_group(group['id'])
                        removed_count += 1
            except Exception as e:
                logging.error(f"Error processing group {group['id']}: {str(e)}")

        # Run the async checks
        loop.run_until_complete(check_groups())
        loop.close()

        updated_groups = telegramDataBase.get_user_groups(current_user.uuid)
        return jsonify({
            "groups": updated_groups,
            "removed": removed_count
        })

    except Exception as e:
        logging.error(f"Refresh failed: {str(e)}")
        return jsonify({"error": "Refresh failed"}), 500




@app.route('/group_settings/<string:group_id>')
@login_required
def group_settings(group_id):
    group = telegramDataBase.get_group_info(group_id, current_user.uuid)
    if not group:
        flash("Group not found or access denied", "error")
        return redirect(url_for('telegram_groups'))
    
    return render_template('group_settings.html',
                         name=group['name'],
                         id=group['id'],
                         type=group['type'],
                         settings=group['settings']) 


################################################################################

############################# Under development ################################
@app.route('/comming_soon')
def comming_soon():
    return render_template('under_development.html')

################################################################################


if __name__ == '__main__':
    try:
        app.run(host='0.0.0.0', port=5050, debug=False, threaded=True, use_reloader=True)
    except:
        logging.error("ERROR RUNNING.")
    finally:
        bot.stop()